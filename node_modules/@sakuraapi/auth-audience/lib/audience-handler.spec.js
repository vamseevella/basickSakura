"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const express = require("express");
const jsonwebtoken_1 = require("jsonwebtoken");
const request = require("supertest");
const audience_handler_1 = require("./audience-handler");
describe('jwtAudienceHandler', () => {
    const mockSapi = {
        config: {}
    };
    const options = {
        audience: 'testAudience',
        issuer: 'testIssuer',
        key: '1234'
    };
    function getMockHandler(authAudience) {
        return (req, res, next) => __awaiter(this, void 0, void 0, function* () {
            const result = yield authAudience.authenticate.bind(authAudience)(req, res);
            if (!result.success) {
                return res.status(result.status).send(result.data || undefined);
            }
            next();
        });
    }
    function setupTestApp(opt) {
        opt = opt || {};
        opt = Object.assign(opt, options);
        const app = express();
        const authAudience = audience_handler_1.addAuthAudience(mockSapi, opt).authenticators[0];
        app.use(getMockHandler((authAudience)));
        app.get('*', (req, res, next) => {
            res.status(200).json({
                fallthrough: true,
                jwt: res.locals.jwt
            });
            next();
        });
        return app;
    }
    it('returns 401 with no Authorization header (#7)', (done) => __awaiter(this, void 0, void 0, function* () {
        const result = yield request(setupTestApp())
            .get('/')
            .expect(401)
            .catch(done.fail);
        const body = result.body;
        expect(body.fallthrough).not.toBeDefined('Auth should not have gotten here');
        done();
    }));
    it('returns 401 when expired', (done) => __awaiter(this, void 0, void 0, function* () {
        const token = jsonwebtoken_1.sign({
            aud: options.audience,
            exp: 0,
            iss: options.issuer
        }, options.key);
        const result = yield request(setupTestApp())
            .get('/')
            .set('Authorization', `Bearer ${token}`)
            .expect(401)
            .catch(done.fail);
        const body = result.body;
        expect(body.fallthrough).not.toBeDefined('Auth should not have gotten here');
        done();
    }));
    it('returns 401 when token is invalid', (done) => __awaiter(this, void 0, void 0, function* () {
        const result = yield request(setupTestApp())
            .get('/')
            .set('Authorization', `Bearer 123`)
            .expect(401)
            .catch(done.fail);
        const body = result.body;
        expect(body.fallthrough).not.toBeDefined('Auth should not have gotten here');
        done();
    }));
    it('returns 400 when the auth scheme does not match', (done) => __awaiter(this, void 0, void 0, function* () {
        const token = jsonwebtoken_1.sign({
            aud: options.audience,
            iss: options.issuer,
            tokenInjected: true
        }, options.key);
        const result = yield request(setupTestApp())
            .get('/')
            .set('Authorization', `JWT ${token}`)
            .expect(400)
            .catch(done.fail);
        const body = result.body;
        expect(body.fallthrough).not.toBeDefined('Auth should not have gotten here');
        done();
    }));
    it('injects jtw token into res.locals.jwt by default when valid auth', (done) => __awaiter(this, void 0, void 0, function* () {
        const payload = {
            aud: options.audience,
            iss: options.issuer,
            tokenInjected: true
        };
        const token = jsonwebtoken_1.sign(payload, options.key);
        const result = yield request(setupTestApp())
            .get('/')
            .set('Authorization', `Bearer ${token}`)
            .expect(200)
            .catch(done.fail);
        const body = result.body;
        expect(body.jwt.aud).toBe(payload.aud);
        expect(body.jwt.iss).toBe(payload.iss);
        expect(body.jwt.tokenInjected).toBe(payload.tokenInjected);
        done();
    }));
    it('supports having no auth scheme set', (done) => __awaiter(this, void 0, void 0, function* () {
        const payload = {
            aud: options.audience,
            iss: options.issuer,
            tokenInjected: true
        };
        const token = jsonwebtoken_1.sign(payload, options.key);
        const result = yield request(setupTestApp({ authScheme: '' }))
            .get('/')
            .set('Authorization', `${token}`)
            .expect(200)
            .catch(done.fail);
        const body = result.body;
        expect(body.jwt.aud).toBe(payload.aud);
        expect(body.jwt.iss).toBe(payload.iss);
        expect(body.jwt.tokenInjected).toBe(payload.tokenInjected);
        done();
    }));
    it('returns 401 when token is invalid and no auth scheme set', (done) => __awaiter(this, void 0, void 0, function* () {
        const result = yield request(setupTestApp())
            .get('/')
            .set('Authorization', `123`)
            .expect(401)
            .catch(done.fail);
        const body = result.body;
        expect(body.fallthrough).not.toBeDefined('Auth should not have gotten here');
        done();
    }));
});
//# sourceMappingURL=audience-handler.spec.js.map